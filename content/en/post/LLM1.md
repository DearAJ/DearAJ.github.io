---
date: 2025-04-20T11:00:59-04:00
description: "LLM 是 Large Language Model（大型语言模型）的缩写，是一种基于人工智能技术的自然语言处理模型。它通过大量的文本数据进行训练，能够理解和生成人类语言，广泛应用于文本生成、翻译、问答、摘要等任务。"
featured_image: "/images/LLM1/pia.jpg"
tags: ["LLM"]
title: "LLM - 1.基础理论"
---

![0](/images/LLM1/0.png)

<!--more-->

&nbsp;

## 1. 绪论

核心目标：对自然语言的概率分布建模

+ **n元语法/n元文法模型**：假设任意单词 wi 出现的概率只与过去 n−1 个词相关。

  + **统计语言模型(SLM)**：使用平滑处理，提高低概率事件，降低高概率事件，使整体的概率分布趋于均匀。
  + **缺点**：长度限制；依赖人工设计的平滑技术；参数多。

+ **基于分布式表示和神经网络的语言模型**

  + **词向量**：词的独热编码被映射为一个低维稠密的实数向量

  + **自监督学习**：深度神经网络需要采用有监督方法，使用标注数据进行训练。

    但由于训练目标可以通过无标注文本直接获得，因此模型的训练仅需要大规模无标注文本。

  + **预训练语言模型(PLM)**：将预训练模型应用于下游任务时，只需要“微调”预训练模型，使用具体任务的标注数据在预训练语言模型上进行监督训练，就可以取得显著的性能提升。

+ **语境学习 (ICL)**：直接使用大语言模型，就可以在很多任务的少样本场景中取得很好的效果。

+ **缩放法则(Scaling Laws)**：模型的性能依赖于模型的规模，包括参数量、数据集大小和计算量，模型的效果会随着三者的指数增加而平稳提升。

<!--more-->

&nbsp;

### 1.1 发展历程

![1](/images/LLM1/1.png)

1. **基础模型阶段**

   此阶段的研究主要集中在语言模型本身，对

   仅编码器（Encoder Only）、编码器-解码器（Encoder-Decoder）、仅解码器（Decoder Only）等各种类型的模型结构都有相应的研究。

   模型大小与 BERT 类似，参数量大都在 10 亿个以上。通常采用预训练微调范式，针对不同下游任务进行微调。

2. **能力探索阶段**

   在直接利用大语言模型进行零样本和少样本学习的基础上，逐渐扩展为利用**生成式**框架针对大量任务进行有监督微调的方法，有效提升了模型的性能。

3. **突破发展阶段**

   从 2022 年开始，大语言模型的数量呈爆发式的增长，各大公司和研究机构都在发布不同类型的大语言模型。

模型类型中，**基础模型**是指仅经过预训练的模型；**对话模型**是指在预训练模型基础上经过有监督微调和强化学习训练的模型，具备对话和完成任务的能力；**推理模型**是指专注于逻辑推理增强的大语言模型。

&nbsp;

### 1.2 构建流程

![2](/images/LLM1/2.png)

1. **预训练**

   基础模型对长文本进行建模，使模型具有语言生成能力：根据输入的提示词，模型可以生成文本补全句子。建模过程构建了包括事实

   性知识(Factual Knowledge)和常识性知识(Commonsense)在内的世界知识(World Knowledge)。

2. **有监督微调(SFT)**

   也称为**指令微调**，利用少量高质量数据集，通过有监督训练使模型具备问题回答、翻译、写作等专业能力。

   SFT 阶段所需的训练数据量较少，不需要消耗大量的计算资源。该阶段的数据选择对 SFT 模型效果有非常大的影响，因此构造少量并且高质量的训练数据是本阶段的研究重点。

3. **奖励建模**

   构建一个文本质量对比模型。奖励模型可以通过二分类模型，对输入的两个结果之间的优劣进行判断。

4. **强化学习**

   根据数十万条提示词，利用前一阶段训练的奖励模型，给出 SFT 模型对提示词回答结果的质量评估，并与语言模型建模目标综合得到更好的效果。

   使用强化学习，在 SFT 模型的基础上调整参数，使最终生成的文本可以获得更高的奖励。

![3](/images/LLM1/3.png)

&nbsp;

&nbsp;

## 2. Transformer 结构

![4](/images/LLM1/4.png)

### 2.1 嵌入表示层

目标：对于输入文本序列，先通过输入嵌入层(Input Embedding)将每个单词转换为其相对应的向量表示。

#### 位置编码：

+ **原因**：Transformer 序列中不再有任何信息能够提示模型单词之间的相对位置关系

+ **内容**：序列中每一个单词所在的**位置都对应一个向量**，这一向量会与单词表示对应**相加**并送入后续模块中做进一步处理。

  ![5](/images/LLM1/5.png)

  + 优点：

    第一，正余弦函数的范围是 [−1,+1]，导出的位置编码与原词嵌入相加，不会使得结果偏离过远而破坏原有单词的语义信息；

    第二，依据三角函数的基本性质，可以得知第 pos + k个位置编码是第 pos 个位置编码的线性组合，意味着位置编码中蕴含着单词之间的距离信息。

&nbsp;

### 2.2 注意力层

**目标**：建模源语言、目标语言任意两个单词之间的依赖关系。

在编码输入序列的每一个单词的表示中，引入查询 q、键 k 和值 v 计算上下文单词对应的权重得分。这些权重反映了**在编码当前单词的表示时，对于上下文不同部分所需的关注程度**。

![6](/images/LLM1/6.png)

1. **点积**：位置i查询向量与其他位置的键向量做点积得到匹配分数 qi·k1,qi·k2,···,qi·kt。
1. **除以放缩因子**：为了防止过大的匹配分数在后续 Softmax 计算过程中导致的梯度爆炸及收敛效率差的问题，这些得分会除以√d以稳定优化
1. **softmax 归一化**：放缩后的得分经过 Softmax 归一化为概率。
1. **相乘**：将上述步骤得到的概率与其他位置的值向量相乘来聚合希望关注的上下文信息，并最小化不相关信息的干扰。

![8](/images/LLM1/8.png)

+ #### 改进：多头注意力机制

  目的：关注上下文的不同侧面

&nbsp;

### 2.3 前馈层

前馈层接收自注意力子层的输出作为输入，并通过一个带有 **ReLU 激活函数**的**两层全连接网络**对输入进行更复杂的非线性变换。

![9](/images/LLM1/9.png)

增大前馈子层隐状态的维度有利于提高最终翻译结果的质量，因此，前馈子层隐状态的维度一般比自注意力子层要大。

&nbsp;

### 2.4 残差连接与层归一化

目的：提升训练的稳定性

1. 使用一条直连通道直接将对应子层的输入连接到输出，避免在优化过程中因网络过深而产生潜在的**梯度消失**问题：

   ![10](/images/LLM1/10.png)

2. 为了使每一层的输入/输出稳定在一个合理的范围内，层归一化技术被进一步引入每个 Transformer 块中

   ![11](/images/LLM1/11.png)

   层归一化技术可以有效地缓解优化过程中潜在的不稳定、收敛速度慢等问题。

&nbsp;

### 2.5 解码器结构

1. #### 掩码多头注意力

   **目的**：对于每一个单词的生成过程，仅有当前单词之前的目标语言序列是可以被观测的，以防模型在训练阶段直接看到后续的文本序列，无法得到有效的训练。

2. #### 多头交叉注意力

   使用交叉注意力方法，同时接收来自**编码器端的输出**和**当前 Transformer 块的前一个掩码注意力层的输出**。

   查询是通过解码器前一层的输出进行投影的，而键和值是使用编码器的输出进行投影的。

   目的：翻译的过程中，为了生成合理的目标语言序列，观测待翻译的源语言序列是什么。

&nbsp;

&nbsp;

## 3. 生成式预训练语言模型 GPT

**GPT**：由多层 Transformer 组成的单向语言模型，主要分为输入层、编码层和输出层三部分。

![12](/images/LLM1/12.png)

### 3.1 自监督预训练

1. **映射（添加位置向量）**

   ![13](/images/LLM1/13.png)

2. **编码层（由 L个 Transformer 模块组成）**

   ![14](/images/LLM1/14.png)

3. **输出层（预测每个位置上的条件概率）**

   ![15](/images/LLM1/15.png)

单向语言模型按照阅读顺序输入文本序列 w，用常规语言模型目标优化 w 的最大似然估计：

![16](/images/LLM1/16.png)

&nbsp;

### 3.2 有监督下游任务微调

**目的**：在通用语义表示的基础上，根据下游任务的特性进行适配。

通常需要利用**有标注数据集**进行训练

1. 文本序列输入 gpt，得到输出后，通过全连接层变换结合 Softmax 函数，得到标签预测结果

   ![17](/images/LLM1/17.png)

2. 优化目标函数

   ![18](/images/LLM1/18.png)

+ 解决**灾难性遗忘**问题（模型遗忘预训练阶段所学习的通用语义知识表示，从而损失模型的通用性和泛化能力

  采用混合 **预训练任务损失** 和 **下游微调损失** 进行微调。

&nbsp;

### 3.3 实践

基于 HuggingFace 的 BERT 模型的构建和使用

&nbsp;

&nbsp;

## 4. 大语言模型的结构

### 4.1 LLaMA 模型

![19](/images/LLM1/19.png)

+ 改进

  1. **前置层归一化**（Pre-normalization）方法

     将第一个层归一化移动到多头自注意力层之前，将第二个层归一化移动到全连接层之前。

  2.  **RMSNorm 归一化函数**

     残差连接的位置调整到多头自注意力层与全连接层之后

     层归一化中采用 RMSNorm 归一化函数

  3. **激活函数**更换为 SwiGLU

  4. **旋转位置嵌入RoPE**

     RoPE 借助复数的思想，通过绝对位置编码的方式实现相对位置编码。也使用逐位相乘⊗操作提高计算速度。

     目标：通过下向量旋转给 q,k 添加绝对位置信息。

&nbsp;

### 4.2 注意力机制优化

常见方法：稀疏近似、低秩近似、利用硬件特性...

#### 4.2.1 稀疏近似

##### 基于位置的稀疏注意力机制

1. 全局注意力（Global Attention）：为了增强模型建模长距离依赖关系的能力，可以**加入一些全局节点**。
2. 带状注意力（Band Attention）：大部分数据都带有局部性，**限制 Query 只与相邻的几个节点进行交互**。
3. 膨胀注意力（Dilated Attention）：与 CNN 中的 Dilated Conv 类似，通过增**加空隙**获取更大的感受野。
4. 随机注意力（Random Attention）：通过**随机采样**，提升非局部的交互能力。
5. 局部块注意力（Block Local Attention）：使用多个**不重叠的块（Block）**来限制信息交互。

![20](/images/LLM1/20.png)

例如：Star-Transformer, Longformer, ETC, BigBird.

##### 基于内容的稀疏注意力机制

根据输入数据创建稀疏注意力。如选择和给定查询q有很高相似度的键k

例如：Routing Transformer, Reformer.

&nbsp;

#### 4.2.2 FlashAttention

![21](/images/LLM1/21.png)

尽可能高效地使用 SRAM 来加快计算速度，避免从全局内存中读取和写入注意力矩阵。FlashAttention 不使用中间注意力矩阵，通过**存储归一化因子**来减少全局内存消耗的方法（将输入分割成块，并在输入块上进行多次传递，以增量的方式执行 Softmax 计算）。

![22](/images/LLM1/22.png)

&nbsp;

#### 4.2.3 多查询注意力

不同的注意力头共享一个键和值的集合，每个头只单独保留了一份查询参数

&nbsp;

#### 4.2.4 多头潜在注意力（MLA）

利用低秩矩阵，实现对压缩潜在键值状态的缓存。

具体来说， MLA 方法的核心是是将传统多头注意力中的键（Key）和值（Vale）进行低秩联合压缩，得到一个低秩表示形式，以减少键值（KV）缓存。

&nbsp;

&nbsp;

## 5. 混合专家模型(MoEs)

**核心思想：模型不同部分（即“专家”）专注不同任务或数据层面。**

MoE 层通常由门控网络 G 和 N 个专家网络 {f1,f2,...,fN } 组成，通常安置于每个 Transformer 模块中前馈层（FFN）。

![23](/images/LLM1/23.png)

### 5.1 稀疏混合专家模型（Sparse MoE）

对于每个输入词元，在前向计算中仅激活专家集合中的一个子集。门控网络通过计算排名前 K位专家的输出加权和来实现稀疏性。

![24](/images/LLM1/24.png)

+ **添加噪声项 R**：

  + 促使不同专家模块之间展开多样化的尝试与协作
  + 打破可能出现的局部最优情况，提高了整个混合专家训练过程的稳定性

+ #### **共享专家模型**：

  问题：采用常规的门控时，分配给不同专家的词元可能需要一些共有知识或信息才能处理，导致专家参数出现冗余。

  DeepSeekMoE 提出了分离 Ks 个专家作为共享专家的思路。无论门控网络所给出的结果如何，每个词元都将被确定性地分配给这些共享专家。

  ![25](/images/LLM1/25.png)

&nbsp;

### 5.2 稠密混合专家模型（Dense MoE）

在前向计算中激活**所有**专家网络 {f1,...,fN }，门控网络根据输入赋予专家不同的权重，不能降低模型计算量。

![27](/images/LLM1/27.png)

但是，将 **LoRA 和 MoE 相结合**，可以在占用很少 GPU 显存的同时，减少微调数据的大规模扩增与**模型世界知识维持**之间存在的冲突。

+ #### **LoRAMoE**

  采用融合混合专家和 LoRA 插件的思想，插件形式确保了在训练阶段冻结主模型，保证了主模型世界知识的完整性。

  ![26](/images/LLM1/26.png)

  + 训练阶段使用**局部平衡约束损失**
    + 一部分专家专注于做下游任务，另一部分专家专注于将指令与主模型的世界知识对齐，以缓解世界知识遗忘。
    + 防止单个专家组内的专家退化现象，使路由平衡地关注于单个专家组的所有专家。

&nbsp;

### 5.3 软混合专家模型（Soft MoE）

根据输入为各个专家分配不同的权重（稠密混合）+ 融合前馈层（MergedFFN）

![28](/images/LLM1/28.png)

该方法通过门控网络分配的权重对不同专家的参数进行融合，仅对融合后的前馈层参数进行计算，始终只计算单个专家的输出。

&nbsp;

&nbsp;
